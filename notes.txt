Member access operator (dot) parsing right now is implemented as a special case binary operator.
Maybe it makes more sense to do it in `parse_sub_expression_no_cast`?

Should we check that all control paths return a value or just default initialize a return value by default?



# Casting rules

## Implicit cast

- Integer conversion with no loss

## Explicit cast

- Integer conversion with loss
- *X -> *Y
- *X -> any int
- any int -> *X




Bytecode:

Functions:

Each parameter (including returned) is aligned to 8 byte boundary.
First, space for return parameters is reserved.
Then, arguments are pushed, the function is called, and parameters are erased from the stack

Return from a function means just write in preallocated by the caller space

Example state of the stack:

ffff
...
previously allocated data
return parameter 0
return parameter 1
parameter 0
parameter 1
return address
saved rbp <- rbp

...
0



idea for templated functions:
To make a template, just don't specify the type of a parameter.
The type then can be obtained using typeof directive:

pow2 :: fn (x) -> #typeof x => x * x;

Also it would be nice to add return type deduction. Like this:

pow2 :: fn (x) => x * x;






