CURRENT RESTRICTIONS:
    MAX 4 bln definitions;
    MAX 4 gb source file

/*
Member access operator (dot) parsing right now is implemented as a special case binary operator.
Maybe it makes more sense to do it in `parse_sub_expression_no_cast`?

Should we check that all control paths return a value or just default initialize a return value by default?



# Casting rules

## Implicit cast

- Integer conversion with no loss

## Explicit cast

- Integer conversion with loss
- *X -> *Y
- *X -> any int
- any int -> *X




Bytecode:

Functions:

Each parameter (including returned) is aligned to 8 byte boundary.
First, space for return parameters is reserved.
Then, arguments are pushed, the function is called, and parameters are erased from the stack

Return from a function means just write in preallocated by the caller space

Example state of the stack:

ffff
...
previously allocated data
return parameter 0
return parameter 1
parameter 0
parameter 1
return address
saved rbp <- rbp

...
0



idea for templated functions:
To make a template, just don't specify the type of a parameter.
The type then can be obtained using typeof directive:
*/
pow2 :: fn (x): #typeof x => x * x;
/*
Also it would be nice to add return type deduction. Like this:
*/
pow2 :: fn (x) => x * x;
/*





Why return type is after arguments?
Because that way it can depend on input types.






Thoughts about characters:
'☺' - utf32 codepoint
`☺` - 



Import string as expression???



// Member functions: c.baz(11, a.foo(42).bar(16));
//
//             Lisp: (baz, c, 11, (bar, (foo, a, 42), 16));
//
//                C: baz(c, 11, bar(foo(a, 42), 16));
//
//             C^-1: (c, 11, ((a, 42)foo, 16)bar)baz;


How arrays should be passed as arguments? How anything relatively big should be passed? Copy or constant reference?
Copy may be too expensive.
Constant arguments may not be modified, so there should be no way to do this: 


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

idea:
`is` from c#, but better.
*/
is cat :: fn (a: *Animal): *Cat {
    return if a.is_cat then a as *Cat else null;
}

animal: *Animal;

if animal is cat kitty {
    meow(kitty);
}

/*
But can null be a valid value for this? When 'something' is 'something else'. I think no.

Also this can be combined with function overloading.

But there may be some problems with parsing when not `binding` an identifier to the result:
*/
if b is cat print("meow"); // `print` identifier is ambiguous - either it is a cat name, or a function name.
/*
I see three solutions:
Use then:
*/
if b is cat then print("meow");
/*
Or use parens:
*/
if (b is cat) print("meow");
/*
Or always `bind` the result:
*/
if b is cat _ print("meow");
/*

Maybe the language should allow definitions to be expressions?
*/
if kitty := cat(animal) print("meyow");
/*
That way we'll have things like this
*/
while (k := get_value()) != 0 {
    // do something with `k` ...
}
/*
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////
// Inline array in a structure //
/////////////////////////////////

InlineString :: struct {
    count : u64;
    data : [? count]u8;
}

// Because the size is unknown at compile time, length of the array is calculated by evaluating user-provided expression.

// Also this struct can only be passed by pointer.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

I think assert should be just a regular function. For that i'll need to implement argument expression string.

